import{_ as k,c as h,a as e,d as i,b as l,w as t,e as a,r as p,o as d}from"./app-gdwmcdjK.js";const r={},g={class:"task-list-container"},c={class:"task-list-item"},o={class:"task-list-item-label",for:"task-item-0"},y={class:"task-list-item"},u={class:"task-list-item-label",for:"task-item-1"},v={class:"task-list-item"},A={class:"task-list-item-label",for:"task-item-2"},b={class:"task-list-container"},m={class:"task-list-item"},B={class:"task-list-item-label",for:"task-item-3"},C={class:"task-list-container"},D={class:"task-list-item"},f={class:"task-list-item-label",for:"task-item-4"},E={class:"task-list-container"},x={class:"task-list-item"},F={class:"task-list-item-label",for:"task-item-5"},_={class:"task-list-container"},z={class:"task-list-item"},q={class:"task-list-item-label",for:"task-item-6"},w={class:"task-list-container"},N={class:"task-list-item"},j={class:"task-list-item-label",for:"task-item-7"},U={class:"task-list-container"},S={class:"task-list-item"},T={class:"task-list-item-label",for:"task-item-8"},V={class:"task-list-container"},G={class:"task-list-item"},I={class:"task-list-item-label",for:"task-item-9"};function P(Z,s){const n=p("font");return d(),h("div",null,[s[28]||(s[28]=e(`<p>如果子类定义了与父类中原型相同的函数会发生什么？<strong>下图中都调用了父类的</strong><code>**show**</code><strong>函数</strong></p><figure><img src="https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658164.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="面向对象新需求" tabindex="-1"><a class="header-anchor" href="#面向对象新需求"><span>面向对象新需求</span></a></h2><p>对于上面这种现象，编译器的做法不是我们期望的，我们期望的是</p><ul><li>根据实际的对象类型来判断重写函数的调用</li><li>如果父类指针指向的是父类对象，则调用父类中定义的函数</li><li>如果父类指针指向的是子类对象，则调用子类中定义的重写函数</li></ul><figure><img src="https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658165.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>解决方案：</p><ul><li>在父类中，在<strong>能让子类重写的函数</strong>的前面加上<code>virtual</code>关键字(必须)</li><li>在子类中，在<strong>重写的父类的虚函数</strong>后面加上<code>override</code>，表示是虚函数重写(非必须，但是加上可以防止重写的虚函数写错)</li></ul><h2 id="多态成立的三要素" tabindex="-1"><a class="header-anchor" href="#多态成立的三要素"><span>多态成立的三要素</span></a></h2><p>:::color3 <strong>多态是设计模式的基础，多态是框架的基础</strong></p><p>:::</p><ul><li>要有继承：多态发生在父子类之间</li><li>要有虚函数重写：重写了虚函数，才能进行动态绑定</li><li>要有父类指针(引用)指向子类对象</li></ul><h2 id="虚析构" tabindex="-1"><a class="header-anchor" href="#虚析构"><span>虚析构</span></a></h2><p><strong>构造函数不能是虚函数。建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数</strong></p><p>析构函数可以是虚的。通过父类指针释放所有的子类资源，<strong>父类写了虚析构，通过父类指针释放对象的时候，才会调用子类的析构函数，否则会产生内存泄漏问题</strong></p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Base</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">	Base</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">		cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> __FUNCSIG__</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	virtual</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> ~Base</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">		cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> __FUNCSIG__</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Derive</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> public</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Base</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	char*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> _str</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">	Derive</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">		_str </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> char</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">10</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">kingkiang</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> };</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">		cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> __FUNCSIG__</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">	~Derive</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">		delete</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> _str</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">		cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> __FUNCSIG__</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	Base</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> base </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Derive</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	delete</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> base</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">			</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">	return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="函数的重载、重写、重定义" tabindex="-1"><a class="header-anchor" href="#函数的重载、重写、重定义"><span>函数的重载、重写、重定义</span></a></h2>`,17)),i("ul",g,[i("li",c,[s[1]||(s[1]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-0",checked:"checked",disabled:"disabled"},null,-1)),i("label",o,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[0]||(s[0]=[a("函数重载")])),_:1})]),s[2]||(s[2]=i("ul",null,[i("li",null,"必须在同一个类中进行(作用域相同)"),i("li",null,"子类无法重载父类的函数，父类同名函数将被名称覆盖"),i("li",null,"重载是在编译期间根据参数类型和个数决定函数调用")],-1))]),i("li",y,[s[4]||(s[4]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-1",checked:"checked",disabled:"disabled"},null,-1)),i("label",u,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[3]||(s[3]=[a("函数重定义")])),_:1})]),s[5]||(s[5]=i("ul",null,[i("li",null,"发生于父类和子类之间，如果子类写了个和父类函数原型一样的函数，并且父类中的函数没有声明为虚函数，则子类会直接覆盖掉父类的函数"),i("li",null,"通过父类指针或引用执行子类对象时，会调用父类的函数")],-1))]),i("li",v,[s[7]||(s[7]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-2",checked:"checked",disabled:"disabled"},null,-1)),i("label",A,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[6]||(s[6]=[a("虚函数重写")])),_:1})]),s[8]||(s[8]=i("ul",null,[i("li",null,"必须发生于父类和子类之间"),i("li",null,"并且父类与子类中的函数必须有完全相同的原型"),i("li",null,[a("使用"),i("code",null,"virtual"),a("声明之后能够产生多态(如果不使用"),i("code",null,"virtual"),a("，那叫重定义)")]),i("li",null,"多态是在运行期间根据具体对象的类型决定函数调用")],-1))])]),s[29]||(s[29]=i("h2",{id:"纯虚函数和抽象类",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#纯虚函数和抽象类"},[i("span",null,"纯虚函数和抽象类")])],-1)),i("ul",b,[i("li",m,[s[10]||(s[10]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-3",checked:"checked",disabled:"disabled"},null,-1)),i("label",B,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[9]||(s[9]=[a("纯虚函数")])),_:1})])])]),s[30]||(s[30]=e(`<p>纯虚函数是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。</p><p>纯虚函数也可以叫抽象函数，一般来说它只有函数名、参数和返回值类型，不需要函数体。这意味着它没有函数的实现，需要让派生类去实现。</p><p>C++中的纯虚函数，一般在函数签名后使用<code>=0</code>作为此类函数的标志。<code>Java、C#</code>等语言中，则直接使用<code>abstract</code>作为关键字修饰这个函数签名，表示这是抽象函数(纯虚函数)。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Animal</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> cry</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4)),i("ul",C,[i("li",D,[s[12]||(s[12]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-4",checked:"checked",disabled:"disabled"},null,-1)),i("label",f,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[11]||(s[11]=[a("抽象类")])),_:1})])])]),s[31]||(s[31]=e(`<p>抽象类是对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。</p><p>通常在编程语句中用 <code>abstract</code> 修饰的类是抽象类。在<code>C++</code>中，<strong>含有纯虚拟函数的类称为抽象类</strong>，它<strong>不能生成对象</strong>；在<code>java</code>中，含有抽象方法的类称为抽象类，同样不能生成对象。</p><p>抽象类是不完整的，它只能用作基类。在面向对象方法中，抽象类主要用来进行<strong>类型隐藏和充当全局变量的角色。</strong></p><pre><code>- 概念理解
</code></pre><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p><p>比如，在一个图形编辑软件的分析设计过程中，就会发现问题领域存在着圆、三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域并不是直接存在的，它就是一个抽象概念。而正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的，<strong>抽象类是不能够实例化</strong>的。</p><pre><code>- 抽象类特征
    * 抽象类不能实例化
    * 抽象类包含抽象方法(纯虚函数)、非抽象方法和属性
    * 从抽象类派生的非抽象类，**必须对继承过来的所有抽象方法实现**
</code></pre>`,7)),i("ul",E,[i("li",x,[s[14]||(s[14]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-5",checked:"checked",disabled:"disabled"},null,-1)),i("label",F,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[13]||(s[13]=[a("关键字abstract和final")])),_:1})]),s[15]||(s[15]=i("ul",null,[i("li",null,[i("code",null,"abstract"),a("："),i("code",null,"MSVC"),a("独有的关键字，申明类为抽象类")])],-1))])]),s[32]||(s[32]=e(`<div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">  Animal</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> abstract</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	Animal a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//error C3622: “Animal”: 声明为“abstract”的类不能被实例化</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">	return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>- \`final\`：C++标准关键字，结束的意思
    * 禁用虚函数重写 
</code></pre><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">  Animal</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">protected</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> show</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	{</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Dog</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Animal</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> show</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">override</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//error C3248: “Animal::show”: 声明为“final”的函数无法被“Dog::show”重写</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	{</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>    * 禁止该类被继承 
</code></pre><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;">  Animal</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  final</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Dog</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> :</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Animal</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> //error C3246: &quot;Dog&quot;: 无法从 &quot;Animal&quot; 继承，因为它已声明为 &quot;final&quot;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="多态探究" tabindex="-1"><a class="header-anchor" href="#多态探究"><span>多态探究</span></a></h2>`,6)),i("ul",_,[i("li",z,[s[17]||(s[17]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-6",checked:"checked",disabled:"disabled"},null,-1)),i("label",q,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[16]||(s[16]=[a("多态的理论基础")])),_:1})])])]),s[33]||(s[33]=i("p",null,[i("strong",null,"静态联编和动态联编"),a("：联编是指一个程序模块、代码之间互相关联的过程。")],-1)),s[34]||(s[34]=i("pre",null,[i("code",null,"-  静态联编(关联)，是程序的匹配、连接在编译阶段实现，也称为早期匹配。**重载函数使用静态联编**。 \n-  动态联编(关联)，是指程序联编推迟到运行时进行，所以又称为动态联编(迟绑定),将函数体和函数调用关联起来，就叫绑定，`switch`语句和`if`语句是动态联编的例子。\n- **那么C++中的动态联编是如何实现的呢？**\n")],-1)),s[35]||(s[35]=i("p",null,"如果我们声明了类中的成员函数为虚函数，那么C++编译器会为类生成一个虚函数表，通过这个表即可实现动态联编",-1)),i("ul",w,[i("li",N,[s[19]||(s[19]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-7",checked:"checked",disabled:"disabled"},null,-1)),i("label",j,[i("strong",null,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[18]||(s[18]=[a("多态的本质(原理)")])),_:1})])])])]),s[36]||(s[36]=e('<p>虚函数表是顺序存放虚函数地址的，虚表是顺序表(数组)，依次存放着类里面的虚函数。<br> 虚函数表是由编译器自动生成与维护的，<strong>相同类的不同对象的虚函数表是一样的</strong>。</p><figure><img src="https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658166.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>既然虚函数表，是一个顺序表，那么它的首地址存放在哪里呢？其实当我们在类中定义了<code>virtual</code>函数时，<code>C++</code>编译器会偷偷的给对象添加一个<code>vptr</code>指针，<code>vptr</code>指针就是存的虚函数表的首地址。</p>',3)),i("ul",U,[i("li",S,[s[23]||(s[23]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-8",checked:"checked",disabled:"disabled"},null,-1)),i("label",T,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[20]||(s[20]=[a("如何证明")])),_:1}),s[22]||(s[22]=i("code",null,'<font style="background-color:#FBDE28;">vptr</font>',-1)),l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[21]||(s[21]=[a("指针存在")])),_:1})])])]),s[37]||(s[37]=e(`<p>我们可以通过求出类的大小判断是否有vptr的存在</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Dog</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> show</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Cat</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	virtual</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> show</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">	cout </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;&lt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Dog size:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> sizeof</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Dog</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Cat size:</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> sizeof</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Cat</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;&lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> endl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">	return</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">output: Dog size:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Cat size:</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">8</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过调试确实能看到vptr指针的存在，而且存放在对象的第一个元素</p><figure><img src="https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658167.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,4)),i("ul",V,[i("li",G,[s[27]||(s[27]=i("input",{type:"checkbox",class:"task-list-item-checkbox",id:"task-item-9",checked:"checked",disabled:"disabled"},null,-1)),i("label",I,[l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[24]||(s[24]=[a("如何找到")])),_:1}),s[26]||(s[26]=i("code",null,'<font style="background-color:#FBDE28;">vptr</font>',-1)),l(n,{style:{"background-color":"#FBDE28"}},{default:t(()=>s[25]||(s[25]=[a("指针呢")])),_:1})])])]),s[38]||(s[38]=e('<p>既然<code>vptr</code>指针存在，那么能不能拿到<code>vptr</code>指针，手动来调用函数呢？答案是可以的，但是操作起来比较麻烦！下面我们就来挖一挖</p><pre><code>1.  因为`vptr`指针在对象的第一个元素(通过证明`vptr`指针的存在可以看出)，所以对对象`t`取地址可以拿到对象的地址 \n</code></pre><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Object</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">obj</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><pre><code>2.  现在拿到的指针的步长是对象的大小，因为`vptr`是指针，只有4/8个字节，所以需要把`p`强转成`int*`指针，这样对`(int*)&amp;t`就得到了`vptr`指针 \n</code></pre><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> vptr </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//拿到了vptr指针的指针</span></span>\n<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pvptr </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">vptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> //把vptr的值转成指针</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>3.  因为`vptr`指针是指向的存储指针数组的首地址，所以拿到`vptr`指针后先把`vptr`转成`int*`指针，这样进行取值的话，刚好是每个指针 \n</code></pre><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">FUN foo </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">FUN</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">pvptr</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><pre><code>4.  接着把得到的数组里面的元素(指针)转成函数指针，即可直接使用了 \n</code></pre><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">using</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> FUN</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)();</span></span>\n<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Parent</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> p </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">obj</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>\n<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">long</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> long</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> vptr </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> *</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">long</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> long*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>\n<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">long</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> long*</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> pvptr </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">long</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> long*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">vptr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>\n<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">auto</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> foo </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">FUN</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">*</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">pvptr </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>\n<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">foo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>\n<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//output:Parent::fun(int i)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',9))])}const M=k(r,[["render",P]]),O=JSON.parse('{"path":"/Cpp/lyzzbocq/","title":"多态","lang":"zh-CN","frontmatter":{"title":"多态","createTime":"2025/04/06 16:52:25","permalink":"/Cpp/lyzzbocq/","description":"如果子类定义了与父类中原型相同的函数会发生什么？下图中都调用了父类的**show**函数 面向对象新需求 对于上面这种现象，编译器的做法不是我们期望的，我们期望的是 根据实际的对象类型来判断重写函数的调用 如果父类指针指向的是父类对象，则调用父类中定义的函数 如果父类指针指向的是子类对象，则调用子类中定义的重写函数 解决方案： 在父类中，在能让子类重写...","head":[["meta",{"property":"og:url","content":"https://xiaokcoding.top/Cpp/lyzzbocq/"}],["meta",{"property":"og:site_name","content":"XiaokCoding"}],["meta",{"property":"og:title","content":"多态"}],["meta",{"property":"og:description","content":"如果子类定义了与父类中原型相同的函数会发生什么？下图中都调用了父类的**show**函数 面向对象新需求 对于上面这种现象，编译器的做法不是我们期望的，我们期望的是 根据实际的对象类型来判断重写函数的调用 如果父类指针指向的是父类对象，则调用父类中定义的函数 如果父类指针指向的是子类对象，则调用子类中定义的重写函数 解决方案： 在父类中，在能让子类重写..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658164.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-14T05:32:06.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-14T05:32:06.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"多态\\",\\"image\\":[\\"https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658164.png\\",\\"https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658165.png\\",\\"https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658166.png\\",\\"https://xiaokcoding-image.oss-cn-beijing.aliyuncs.com/20250406164658167.png\\"],\\"dateModified\\":\\"2025-04-14T05:32:06.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":7.89,"words":2367},"git":{"updatedTime":1744608726000,"contributors":[{"name":"xiaokcoding","username":"xiaokcoding","email":"1512392199@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/xiaokcoding?v=4","url":"https://github.com/xiaokcoding"}]},"autoDesc":true,"filePathRelative":"notes/Cpp/07 . 多态.md"}');export{M as comp,O as data};
